<!DOCTYPE html>
<html>
  <head>
    <style>
      #wp2 {
        overflow: hidden;
        user-select: none;
        width: 100vw;
        height: 90vh;
      }

      #image-container {
        display: grid;
        width: 100%;
        height: 100%;
        max-height: 100%;
        max-width: 100%;
        grid-auto-rows: 512px;
      }
    </style>
  </head>
  <body>
    <input type="radio" name="style" value="color" checked> Color
    <input type="radio" name="style" value="bw"> Black & White

    <div id="wp2">
      <div id="image-container">
      </div>
    </div>
    <script>
      let wp2 = document.getElementById('wp2');
      let wp2Container = document.getElementById('image-container');
      let prevZoom = -1;
      let zoom = 3; 
      let offsetX = 0;
      let offsetY = 0;

      wp2.addEventListener('wheel', e => {
        const delta = e.deltaY;
        const mouseX = e.clientX - wp2.getBoundingClientRect().left;
        const mouseY = e.clientY - wp2.getBoundingClientRect().top;
        if (delta > 0) {
          zoom--;
          if (zoom < 1) zoom = 1;
        } else {
          zoom++; 
          if (zoom > 8) zoom = 8;
        }
        updateImage(mouseX, mouseY);  
      });

      wp2.addEventListener('mousedown', e => {
        e.preventDefault();
        let startX = e.clientX - offsetX;
        let startY = e.clientY - offsetY;

        function move(e) {
          offsetX = e.clientX - startX;
          offsetY = e.clientY - startY;
          updateImage();
        }

        function up() {
          window.removeEventListener('mousemove', move);
          window.removeEventListener('mouseup', up);
        }

        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', up);
      });

      async function loadImage(img, src, skipCheck = false) {
        if (skipCheck) { // If we don't need to wait for the response, just set the src and return the img
          img.src = src;
          return img;
        }
        return new Promise((resolve, reject) => { // This promise is so we can await on the response of the image
          img.src = src;
          img.onload = () => resolve(img);
          img.onerror = reject;
        });
      }

      async function updateImage(mouseX = 0, mouseY = 0, forceUpdate = false) {
        if (prevZoom !== zoom || forceUpdate) { // If the zoom has changed, we need to recompute the grid
          wp2Container.innerHTML = '';
          let layer = Math.max(1, Math.min(8, Math.floor(zoom)));
          let i = 1; // Row iterator
          let breaki = false; // Should break outer loop
          let j = 1; // Col iterator
          let maxj = 1; // Maximum number of columns in the grid

          let minWidth = -1; // To compute bottom right corner size
          let minHeight = -1; // To compute bottom right corner size
          outer: while (!breaki) {
            let rowSafe = false; // If this row has at least one image
            inner: while (true) {
              if (i > 1 && j > maxj) break inner; // If we have already found the maximum number of columns in the grid, just break when we hit it
              let img = document.createElement('img');

              try {
                // j < maxj && rowSafe is to skip waiting for the response if we already know there are at least this many images in the row
                // This is to massively speed up the loading of the grid, since we don't have to wait for the response of the inner images.
                const imgResp = await loadImage(img, `http://194.113.74.157:3000/tiles/l${layer}/${i}/${j}?style=${getStyle()}`, j < maxj && rowSafe);
                if (imgResp) {
                  rowSafe = true; // We have at least one image in the row, so we can continue skipping for this row
                  img.style.maxWidth = `512px`;
                  img.style.maxHeight = `512px`;
                  img.style.objectFit = "cover";
                  wp2Container.appendChild(img);
                  j++;
                } else {
                  if (j-1 > maxj) maxj = j-1;
                  if (j == 1) breaki = true;
                  break inner; // If we don't get a response, we are at the end of the row
                }
              } catch (e) {
                if (j-1 > maxj) maxj = j-1;
                if (j == 1) breaki = true;
                break inner; // If we don't get a response, we are at the end of the row
              }
            }
            if (breaki) break outer;
            i++; 
            j = 1;
          }
          console.log(` rows: ${i-1} cols: ${maxj}`)
          wp2Container.style.gridTemplateColumns = `repeat(${maxj}, 512px)`; // Calculate the grid columns

          // Scale the offset for the new zoom
          // Offset is first scaled by the zoom factor, then we modify it to keep the mouse position in the same place
          // I have no idea why the multiplier is 1 and -0.5, but it works
          const zoomDirection = zoom > prevZoom;
          if (!forceUpdate) {
            offsetX = (offsetX) * (zoomDirection ? 2 : 0.5) - (mouseX * (zoomDirection ? 1 : -0.5));
            offsetY = (offsetY) * (zoomDirection ? 2 : 0.5) - (mouseY * (zoomDirection ? 1 : -0.5));
          }
          prevZoom = zoom;
        }
        wp2Container.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      }

      function getStyle() {
        return document.querySelector('input[name="style"]:checked').value; 
      }

      document.querySelectorAll('input[name="style"]').forEach((radio) => {
        radio.addEventListener('change', () => {
          updateImage(0, 0, true);
        });
      });
      updateImage();
    </script>
  </body>
</html>